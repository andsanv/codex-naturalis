@startuml

' skinparam linetype ortho

scale 4000x4000

package card {
    enum CardSide << enumeration >> {
        + BACK
        + FRONT
    }


    abstract class Card {
        {abstract} + Card(int):
        - id: int
        + getId(): int
        + equals(Object): boolean
    }

    abstract class PlayableCard {
        ~ PlayableCard(int, Map<CornerPosition, Corner>, Map<CornerPosition, Corner>):
        - playedSide: CardSide
        - backCorners: Map<CornerPosition, Corner>
        - activeCorners: Map<CornerPosition, Corner>
        - frontCorners: Map<CornerPosition, Corner>
        + getPlayedSide(): CardSide
        + enoughResources(Map<CornerItems, Integer>): boolean
        + playSide(CardSide): void
        + getActiveCorners(): Map<CornerPosition, Corner>
        + setCorner(CornerPosition, Corner): void
    }

    class GoldCard {
        + GoldCard(int, Resources, GoldCardPoints, Map<Resources, Integer>, Map<CornerPosition, Corner>, Map<CornerPosition, Corner>):
        + requiredResources: Map<Resources, Integer>
        + type: Resources
        + points: GoldCardPoints
        + enoughResources(Map<CornerItems, Integer>): boolean
    }

    enum GoldCardPoints << enumeration >> {
        + ONE
        + THREE
        + FIVE
        + ONE_PER_QUILL
        + ONE_PER_INKWELL
        + ONE_PER_MANUSCRIPT
        + TWO_PER_COVERED_CORNER
    }

    class ObjectiveCard {
        + ObjectiveCard(int, int, ObjectiveStrategy):
        + points: int
        - objectiveStrategy: ObjectiveStrategy
        + computePoints(PlayerBoard): int
    }

    class ResourceCard {
        + ResourceCard(int, Resources, ResourceCardPoints, Map<CornerPosition, Corner>, Map<CornerPosition, Corner>):
        + type: Resources
        + points: ResourceCardPoints
    }
    enum ResourceCardPoints << enumeration >> {
        + ZERO
        + ONE
    }

    enum Resources << enumeration >> {
        + PLANT
        + INSECT
        + FUNGI
        + ANIMAL
    }

    class StarterCard {
        + StarterCard(int, Set<Resources>, Map<CornerPosition, Corner>, Map<CornerPosition, Corner>):
        + centralResources: Set<Resources>
    }

    Card ^-- PlayableCard
    Card ^--  ObjectiveCard

    Card -> CardSide

    PlayableCard              ^--  ResourceCard
    PlayableCard              ^--  GoldCard
    PlayableCard              ^--  StarterCard

    ResourceCard --> ResourceCardPoints
    ResourceCard --> Resources

    GoldCard --> GoldCardPoints
    GoldCard --> Resources

    package objective {
        interface ObjectiveStrategy << interface >> {
            + getCompletedOccurrences(PlayerBoard): int
        }

        class ItemsObjectiveStrategy {
            + ItemsObjectiveStrategy(Map<CornerItems, Integer>):
            ~ requiredItems: Map<CornerItems, Integer>
            + getCompletedOccurrences(PlayerBoard): int
        }

        class PatternObjectiveStrategy {
            + PatternObjectiveStrategy(CornerItems[][]):
            ~ pattern: CornerItems[][]
            + getCompletedOccurrences(PlayerBoard): int
        }

        ObjectiveStrategy    <|..  ItemsObjectiveStrategy
        ObjectiveStrategy    <|..  PatternObjectiveStrategy
    }

    ObjectiveCard o--> ObjectiveStrategy
}


package corner {
    abstract class Corner {
        + canPlaceCardAbove(): boolean
    }

    enum CornerItems << enumeration >> {
        + EMPTY
        + PLANT
        + ANIMAL
        + FUNGI
        + INSECT
        + QUILL
        + INKWELL
        + MANUSCRIPT
    }

    enum CornerPosition << enumeration >> {
        + TOP_LEFT
        + TOP_RIGHT
        + BOTTOM_RIGHT
        + BOTTOM_LEFT
    }

    class CoveredCorner {
        + CoveredCorner():
        + canPlaceCardAbove(): boolean
    }

    class HiddenCorner {
        + HiddenCorner():
        + canPlaceCardAbove(): boolean
    }

    class VisibleCorner {
        + VisibleCorner(CornerItems):
        - item: CornerItems
        + getItem(): CornerItems
        + canPlaceCardAbove(): boolean
    }

    Corner <|-- HiddenCorner
    Corner <|-- CoveredCorner
    Corner <|-- VisibleCorner

    CornerPosition "4"--- PlayableCard


    CornerItems - VisibleCorner
}

package deck {
    class Deck<T> {
        ~ Deck(List<T>):
        - deck: Stack<T>
        + draw(): Optional<T>
        + isEmpty(): boolean
        + toString(): String
    }

    interface DeckCreator << interface >> {
        + createDeck(): Deck<Card>
    }

    class ResourceDeckCreator {
        + ResourceDeckCreator():
        - path: Path
        + createDeck(): Deck<ResourceCard>
    }

    class GoldDeckCreator {
        + GoldDeckCreator():
        - path: Path
        + createDeck(): Deck<GoldCard>
    }

    class StarterDeckCreator {
        + StarterDeckCreator():
        - path: Path
        + createDeck(): Deck<StarterCard>
    }

    class ObjectiveDeckCreator {
        + ObjectiveDeckCreator():
        - path: Path
        + createDeck(): Deck<ObjectiveCard>
    }

    DeckCreator <|.. ResourceDeckCreator
    DeckCreator <|.. GoldDeckCreator
    DeckCreator <|.. StarterDeckCreator
    DeckCreator <|.. ObjectiveDeckCreator

    Deck - DeckCreator: creates
}

package player {
    class Coords {
        + Coords(int, int):
        + y: int
        + x: int
        + equals(Object): boolean
    }

    class Player {
        + Player(ObjectiveCard):
        + secretObjective: ObjectiveCard
        - playerBoard: PlayerBoard
        - hand: PlayerHand
        + playCard(Coords, PlayableCard): boolean
        + getHand(): PlayerHand
        + getBoard(): PlayerBoard
    }

    class PlayerBoard {
        ~ PlayerBoard(StarterCard):
        ~ PlayerBoard(PlayerBoard):
        - board: Map<Coords, PlayableCard>
        - playerItems: Map<CornerItems, Integer>
        - STARTER_CARD_COORDINATES: Coords
        + setCard(Coords, PlayableCard): void
        + getVisibleItems(): Map<CornerItems, Integer>
        - adjacentCards(Coords): Map<CornerPosition, PlayableCard>
        + canPlaceCardAt(Coords, PlayableCard): boolean
        - adjacentCorners(Coords): Map<CornerPosition, Corner>
        + getBoard(): HashMap<Coords, PlayableCard>
        - adjacentCoords(Coords): Map<CornerPosition, Coords>
        + getCard(Coords): PlayableCard
    }

    class PlayerHand {
        + PlayerHand(List<PlayableCard>):
        + PlayerHand(PlayerHand):
        - cards: List<PlayableCard>
        + removeCard(PlayableCard): void
        + getCards(): List<PlayableCard>
        + addCard(PlayableCard): void
    }

    enum PlayerToken << enumeration >> {
        + BLUE
        + GREEN
        + RED
        + YELLOW
    }

    Player  *-- "1"  PlayerBoard
    Player  *-- "1"  PlayerHand

    PlayerBoard "1" --> "0..*" Coords: uses
}

class ScoreTrack {
    + ScoreTrack(List<Player>):
    - maxScore: int
    - scores: Map<Player, Integer>
    + gameEnded(): boolean
    + getScore(): Map<Player, Integer>
    + updatePlayerScore(Player, Integer): void
}

GameModel "1" -- "2..4" Player
GameModel "1" *-- "1" ScoreTrack

Deck o---> Card : contains

PlayableCard o-----> Corner : contains

GameModel "1" *-- "4" Deck

PlayerToken "2..4" <-- GameModel: tracks

@enduml