@startuml

package Client {
    ' View related classes
    abstract class UI

    class GUI extends UI
    class TUI extends UI

    class View {
        - userInterface: UI
    }

    View <-- "1" UI

    class ClientController {
        - networkProtocol: ClientNetworkProtocol
    }

    ' MVC client view controller relationship

    View --> ClientController: notify user action
    ClientController --> View: update/modify view
}

package Server {

    ' This class handles the connection with the client
    class PlayerConnectionHandler {
        - playerConnection: ServerNetworkProtocol
    }

    ' Controller for a single game
    class GameController {
        - model: GameModel
        - playersConnections: ServerNetworkProtocol[]
    }

    ' MVC server controller/model relationship
    GameController --> GameModel: uses

    ' This class represents a single running game
    class Game {
        - gameController: GameController
    }

    Game --> GameController

    class GameServer {
        - games: Game[]
        - playersConnected: PlayerConnection[]
        + startServer()
        + stopServer()
        + joinGame()
    }

    GameServer "1" --> "0...N" Game

    ' TODO discuss add, remove, modify
    class GameModel {
        - players: Player[4]
        - playersSequence: Player[4]
        - id: String
        - scoreTrack: ScoreTrack
        - starterDeck: StarterDeck
        - goldCardDeck: GoldCardDeck
        - objectiveDeck: CommonObjectivesCards
        - resourceCardDeck: ResourceCardDeck
        - drawableVisibleCards: DrawableVisibleCards
        - turn: int
        - currentPlayer: Player
    }

    GameModel --> "1" ResourceCardDeck
    GameModel --> "1" StarterDeck
    GameModel --> "1" GoldCardDeck
    GameModel --> "1" CommonObjectivesCards
    GameModel --> "1" DrawableVisibleCards
    GameModel --> "1" ScoreTrack

    ' TODO Discuss starterPlayer: we could use decorator pattern
    class Player {
        - nickname: String
        - id: String
        - color: Token
        - points: int
        - isCurrentPlayer: boolean

        - playerHand: PlayerHand
        - secretObjective: ObjectiveCard
        - playerBoard: PlayerBoard
    }

    Player --> "1" Token
    Player --> "1" PlayerHand
    Player --> "1" PlayerBoard


    class PlayerHand {
        cards: PlayableCard[3]
    }


    class PlayerBoard {
        /' TODO: Discuss implentation possibilities:
            1- Bidimensional matrix preallocated
            2- Bidimensional matrix dynamically allocated (overengineering)
            3- Card corners linking to other cards with pointers
            4- Search others solutions online
        '/
    }

    abstract class Card {
        ' - getFront(): CardSide
        ' - getBack(): CardSide
    }

    /' abstract class CardSide {

    }

    '/

    class ScoreTrack {
        - points: HashMap<Player, int>

        - move(player: Player, int points): void
        - notifyLastRound(): void
    }

    class Token {
        color: TokenColor
    }

    enum TokenColor {
        RED
        BLUE
        GREEN
        YELLOW
        BLACK
    }

    Token --> TokenColor

    abstract class PlayableCard extends Card {
        - draw(): void
        - place(): void
        - corners: Corner[4]
        - color: Color
    }

    class GoldCard extends PlayableCard {
        - points: Points
        ' TODO Only on placement, objects added later don't give you points
        - requisiteForPoints: RequisiteForPoints
        ' From 3 to 5
        - requiredResources: ResourceType[]
    }
    GoldCard --> Points
    GoldCard --> RequisiteForPoints

    enum RequisiteForPoints {
        QUILL
        INKWELL
        MANUSCRIPT
        NONE
    }

    class ResourceCard extends PlayableCard {
        - points: Points
    }
    ResourceCard --> Points

    class StarterCard extends PlayableCard {
        ' TODO See correct syntax
        - color: Color = Color.NONE
        ' TODO From 1 to 3
        - centralResources: ResourceType[]
    }


    class ObjectiveCard extends Card {
        - objective: Objective
    }

    abstract class Objective {
        - points: Points
    }

    class ResourcesObjective extends Objective {
        - color: Color
    }

    class PatternsObjective extends Objective {
        - pattern: Pattern
    }

    PatternsObjective --> Pattern

    class ObjectsObjective extends Objective {
        /' - object: Combinations
        TODO Discuss and change type
        '/
    }
    ObjectsObjective --> Combinations

    abstract class Deck

    class StarterDeck extends Deck {
        - cards: StarterCard[]
    }

    class GoldCardDeck extends Deck {
        - cards: GoldCard[]
    }

    class ObjectiveCardDeck extends Deck {
        - cards: ObjectiveCard[]
    }

    class ResourceCardDeck extends Deck {
        - cards: ResourceCard[]
    }

    class DrawableVisibleCards {
        + resourceCard: ResourceCard[2]
        + goldCard: GoldCard[2]
    }

    class CommonObjectivesCards {
        + objectiveCard: ObjectiveCard[2]
    }

    enum Points {
        1, 2, 3, 5
    }

    enum Pattern {
        1, 2, 3, 4, 5, 6, 7, 8
        'TODO Hardcode the eight patterns
    }

    enum Combinations {
        TRIS
        QUILL
        INKWELL
        MANUSCRIPT
        'TODO Discuss with ObjectsObjective (see above)
    }


    class Corner {
        - cornerVisibility: CornerVisibility
        - cornerPosition: CornerPosition
        - resourceType: ResourceType
        - cornerState: CornerState
    }

    enum CornerState {
        CLEAR
        COVERED
    }

    enum CornerVisibility {
        VISIBLE
        HIDDEN
    }

    enum CornerPosition {
        TOP_LEFT
        TOP_RIGHT
        BOTTOM_LEFT
        BOTTOM_RIGHT
    }

    enum Color {
        RED
        GREEN
        PURPLE
        BLUE
        ' TODO discuss about "NONE" color for starter card implementation
        NONE
    }

    enum ResourceType {
        PLANT
        ANIMAL
        FUNGI
        INSECT
        QUILL
        INKWELL
        MANUSCRIPT
        EMPTY
    }



    PlayableCard --> "4" Corner
    PlayableCard --> Color
    Corner --> ResourceType
    Corner --> CornerState
    Corner --> CornerPosition
    Corner --> CornerVisibility

    ObjectiveCard --> Objective

}

package Networking {
    ' This abstract class handles communications for the client
    abstract class ClientNetworkProtocol
    class RMIClientProtocol extends ClientNetworkProtocol
    class SocketClientProtocol extends ClientNetworkProtocol


    ' This abstract class handles communications for the server
    abstract class ServerNetworkProtocol
    class RMIServerProtocol extends ServerNetworkProtocol
    class SocketServerProtocol extends ServerNetworkProtocol
}

' Networking relations6
ClientController "0..1" <-- "1" ClientNetworkProtocol
GameController "1" <-- "1..4" ServerNetworkProtocol

' MVC client controller / server controller relation
ClientController "1" <-[#red]-> "1..4" GameController: connected
' TODO to join/create a game the client controller must connect directly to the game server

@enduml
